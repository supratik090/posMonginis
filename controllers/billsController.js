const billsModel = require("../models/billsModel");
const returnModel = require("../models/returnModel");
const inventoryModel = require("../models/inventoryModels");
const customerModel = require("../models/customerModel");
const moment = require("moment-timezone");


//add items
const addBillsController = async (req, res) => {
  try {
  console.log(req.body);
    const newBill = new billsModel(req.body);
    await newBill.save();

     const { cartItems, subTotal, totalAmount, userId } = req.body;

      // Process each cart item in the sale
         for (const cartItem of cartItems) {
           let remainingQty = cartItem.quantity; // quantity sold for this item
           // Find all inventory records for the code, ordered by oldest first
           const inventories = await inventoryModel.find({ code: cartItem.code, quantity: { $gt: 0 } }).sort({ createdAt: 1 });

           // Iterate over inventory records and reduce quantity FIFO
           for (let inv of inventories) {
             if (remainingQty <= 0) break;
             if (inv.quantity >= remainingQty) {
               // If inventory record can cover the remaining quantity, subtract it and finish
               inv.quantity -= remainingQty;
               remainingQty = 0;
               console.log(" Available in stock ", cartItem.code);
               await inv.save();
             } else {
               // Not enough in this record, deplete it and reduce remaining quantity
               remainingQty -= inv.quantity;
               inv.quantity = 0;
               console.log(" Not enough in stock making it 0", cartItem.code);
               await inv.save();
             }
           }
           // If remainingQty is still > 0 (either because no inventory was found or insufficient stock),
           // create a new inventory record with negative quantity.
           if (remainingQty > 0) {
            console.log("Creating negative inventory please rectify", cartItem.code);
             await Inventory.create({
               code: cartItem.code,
               price: cartItem.price,  // you can choose to record the sale price
               quantity: -remainingQty,
                invoiceNumber: "Autogenerated",
             });
           }
         }

    res.send("Bill Created Successfully!");
  } catch (error) {
    res.send("something went wrong");
    console.log(error);
  }
};
const getBillsController = async (req, res) => {
  try {
    const { date } = req.query; // "2025-02-25"
    console.log("Query Date (IST):", date);

    // Parse the provided date in IST without conversion to UTC
    const start = moment.tz(date, "YYYY-MM-DD", "Asia/Kolkata").startOf("day").toDate();
    const end = moment.tz(date, "YYYY-MM-DD", "Asia/Kolkata").endOf("day").toDate();

    console.log("Querying MongoDB from:", start, "to", end);

    const bills = await billsModel.find({
      date: { $gte: start, $lte: end },
    });

    console.log("Bills for selected date:", bills);
    res.json(bills);
  } catch (error) {
    console.error("Error fetching bills:", error);
    res.status(500).send("Server Error");
  }
};

const addReturnsController = async (req, res) => {
  try {
    console.log(req.body);

    const { creditNote } = req.body;
    if (!creditNote) {
      return res.status(400).send("Credit Note Number is required");
    }

    // Replace or insert the document (upsert = true)
    await returnModel.findOneAndUpdate(
      { _id: creditNote  },
      req.body,
      { upsert: true, new: true }
    );

    res.send("Return saved/replaced successfully!");
  } catch (error) {
    console.error("Error saving return: ", error);
    res.status(500).send("Something went wrong");
  }
};




module.exports = {
  addBillsController,
  getBillsController,
  addReturnsController,
};